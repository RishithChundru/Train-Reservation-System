{"version":3,"names":["_core","require","validateUsage","path","state","tdzEnabled","dynamicTDZNames","name","Object","keys","getBindingIdentifiers","binding","scope","getBinding","injectTDZChecks","push","node","kind","disallowConstantViolations","violation","constantViolations","readOnlyError","addHelper","throwNode","t","callExpression","stringLiteral","isAssignmentExpression","operator","left","right","exprs","replaceWith","sequenceExpression","includes","logicalExpression","slice","binaryExpression","isUpdateExpression","unaryExpression","get","isForXStatement","ensureBlock","variableDeclaration","variableDeclarator","generateUidIdentifier","body","unshift","expressionStatement","getTDZStatus","refPath","bindingPath","executionStatus","_guessExecutionStatusRelativeTo","skipTDZChecks","WeakSet","buildTDZAssert","status","clone","cloneNode","add","getTDZReplacement","id","_path$scope$getBindin","has","isFunctionDeclaration","parent","_tdzThis","allUsages","Set","referencePaths","forEach","dynamicTdz","arg","replacement","insertBefore","nodes","ids","length","parentPath","isFor"],"sources":["../src/validation.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { Scope, NodePath, PluginPass } from \"@babel/core\";\n\nexport function validateUsage(\n  path: NodePath<t.VariableDeclaration>,\n  state: PluginPass,\n  tdzEnabled: boolean,\n) {\n  const dynamicTDZNames = [];\n\n  for (const name of Object.keys(path.getBindingIdentifiers())) {\n    const binding = path.scope.getBinding(name);\n    // binding may be null. ref: https://github.com/babel/babel/issues/15300\n    if (!binding) continue;\n    if (tdzEnabled) {\n      if (injectTDZChecks(binding, state)) dynamicTDZNames.push(name);\n    }\n    if (path.node.kind === \"const\") {\n      disallowConstantViolations(name, binding, state);\n    }\n  }\n\n  return dynamicTDZNames;\n}\n\nfunction disallowConstantViolations(\n  name: string,\n  binding: Scope.Binding,\n  state: PluginPass,\n) {\n  for (const violation of binding.constantViolations) {\n    const readOnlyError = state.addHelper(\"readOnlyError\");\n    const throwNode = t.callExpression(readOnlyError, [t.stringLiteral(name)]);\n\n    if (violation.isAssignmentExpression()) {\n      const { operator, left, right } = violation.node;\n      if (operator === \"=\") {\n        const exprs = [right];\n        exprs.push(throwNode);\n        violation.replaceWith(t.sequenceExpression(exprs));\n      } else if ([\"&&=\", \"||=\", \"??=\"].includes(operator)) {\n        violation.replaceWith(\n          t.logicalExpression(\n            // @ts-expect-error todo: give a better type to operator\n            operator.slice(0, -1),\n            left,\n            t.sequenceExpression([right, throwNode]),\n          ),\n        );\n      } else {\n        violation.replaceWith(\n          t.sequenceExpression([\n            t.binaryExpression(\n              // @ts-expect-error todo: give a better type to operator\n              operator.slice(0, -1),\n              left,\n              right,\n            ),\n            throwNode,\n          ]),\n        );\n      }\n    } else if (violation.isUpdateExpression()) {\n      violation.replaceWith(\n        t.sequenceExpression([\n          t.unaryExpression(\"+\", violation.get(\"argument\").node),\n          throwNode,\n        ]),\n      );\n    } else if (violation.isForXStatement()) {\n      violation.ensureBlock();\n      violation\n        .get(\"left\")\n        .replaceWith(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(violation.scope.generateUidIdentifier(name