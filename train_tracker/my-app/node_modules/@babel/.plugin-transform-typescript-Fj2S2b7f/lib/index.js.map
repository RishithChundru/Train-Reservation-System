{"version":3,"names":["_helperPluginUtils","require","_pluginSyntaxTypescript","_helperCreateClassFeaturesPlugin","_constEnum","_enum","_globalTypes","_namespace","isInType","path","parent","type","parentPath","findParent","exportKind","NEEDS_EXPLICIT_ESM","WeakMap","PARSED_PARAMS","WeakSet","safeRemove","ids","getBindingIdentifiers","name","Object","keys","binding","scope","getBinding","identifier","removeBinding","opts","noScope","remove","assertCjsTransformEnabled","pass","wrong","suggestion","extra","file","get","buildCodeFrameError","_default","exports","default","declare","api","types","t","template","assertVersion","JSX_PRAGMA_REGEX","allowNamespaces","jsxPragma","jsxPragmaFrag","onlyRemoveTypeImports","optimizeConstEnums","allowDeclareFields","classMemberVisitors","field","node","value","decorators","definite","isClassPrivateProperty","abstract","accessibility","readonly","optional","typeAnnotation","override","method","constructor","classPath","assigns","paramPath","param","parameter","has","add","id","isIdentifier","isAssignmentPattern","left","push","statement","ast","cloneNode","replaceWith","registerBinding","injectInitialization","inherits","syntaxTypeScript","visitor","Pattern","visitPattern","Identifier","RestElement","Program","enter","state","fileJsxPragma","fileJsxPragmaFrag","programScope","GLOBAL_TYPES","set","Set","comments","comment","jsxMatches","exec","pragmaImportName","split","pragmaFragImportName","stmt","isImportDeclaration","program","importKind","specifier","specifiers","registerGlobalType","local","importsToRemove","specifiersLength","length","isAllSpecifiersElided","size","isImportTypeOnly","programPath","importPath","isTSImportEqualsDeclaration","isExport","isExportDeclaration","isVariableDeclaration","isTSTypeAliasDeclaration","isTSDeclareFunction","isTSInterfaceDeclaration","isClassDeclaration","isTSEnumDeclaration","isTSModuleDeclaration","exit","sourceType","pushContainer","exportNamedDeclaration","ExportNamedDeclaration","source","every","isExportSpecifier","isGlobalType","declaration","namespace","isStringLiteral","getFirstIdentifier","hasOwnBinding","newExport","replaceWithMultiple","variableDeclaration","variableDeclarator","registerDeclaration","ExportAllDeclaration","ExportSpecifier","ExportDefaultDeclaration","TSDeclareFunction","TSDeclareMethod","VariableDeclaration","VariableDeclarator","TSIndexSignature","ClassDeclaration","Class","typeParameters","superTypeParameters","implements","forEach","child","isClassMethod","isClassPrivateMethod","kind","isClassProperty","isClassAccessorProperty","Function","returnType","params","shift","TSModuleDeclaration","transpileNamespace","TSInterfaceDeclaration","TSTypeAliasDeclaration","TSEnumDeclaration","const","transpileConstEnum","transpileEnum","TSImportEqualsDeclaration","moduleReference","init","varKind","isTSExternalModuleReference","callExpression","expression","entityNameToExpr","newNode","TSExportAssignment","TSTypeAssertion","tsSatisfiesExpression","isTSAsExpression","isTSSatisfiesExpression","tsInstantiationExpression","CallExpression","OptionalCallExpression","NewExpression","JSXOpeningElement","TaggedTemplateExpression","isTSQualifiedName","memberExpression","right","referencePaths","sourceFileHasJsx","traverse","JSXElement|JSXFragment","stop"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxTypeScript from \"@babel/plugin-syntax-typescript\";\nimport type { PluginPass, types as t, Scope, NodePath } from \"@babel/core\";\nimport { injectInitialization } from \"@babel/helper-create-class-features-plugin\";\nimport type { Options as SyntaxOptions } from \"@babel/plugin-syntax-typescript\";\n\nimport transpileConstEnum from \"./const-enum.ts\";\nimport type { NodePathConstEnum } from \"./const-enum.ts\";\nimport transpileEnum from \"./enum.ts\";\nimport {\n  GLOBAL_TYPES,\n  isGlobalType,\n  registerGlobalType,\n} from \"./global-types.ts\";\nimport transpileNamespace, { getFirstIdentifier } from \"./namespace.ts\";\n\nfunction isInType(path: NodePath) {\n  switch (path.parent.type) {\n    case \"TSTypeReference\":\n    case process.env.BABEL_8_BREAKING\n      ? \"TSClassImplements\"\n      : \"TSExpressionWithTypeArguments\":\n    case process.env.BABEL_8_BREAKING\n      ? \"TSInterfaceHeritage\"\n      : \"TSExpressionWithTypeArguments\":\n    case \"TSTypeQuery\":\n      return true;\n    case \"TSQualifiedName\":\n      return (\n        // `import foo = ns.bar` is transformed to `var foo = ns.bar` and should not be removed\n        path.parentPath.findParent(path => path.type !== \"TSQualifiedName\")\n          .type !== \"TSImportEqualsDeclaration\"\n      );\n    case \"ExportSpecifier\":\n      return (\n        // export { type foo };\n        path.parent.exportKind === \"type\" ||\n        // export type { foo };\n        // @ts-expect-error: DeclareExportDeclaration does not have `exportKind`\n        (path.parentPath as NodePath<t.ExportSpecifier>).parent.exportKind ===\n          \"type\"\n      );\n    default:\n      return false;\n  }\n}\n\n// Track programs which contain imports/exports of values, so that we can include\n// empty exports for programs that do not, but were parsed as modules. This allows\n// tools to infer unambiguously that results are ESM.\nconst NEEDS_EXPLICIT_ESM = new WeakMap();\nconst PARSED_PARAMS = new WeakSet();\n\n// A hack to avoid removing the impl Binding when we remove the declare NodePath\nfunction safeRemove(path: NodePath) {\n  const ids = path.getBindingIdentifiers();\n  for (const name of Object.keys(ids)) {\n    const binding = path.scope.getBinding(name);\n    if (binding && binding.identifier === ids[name]) {\n      binding.scope.removeBinding(name);\n    }\n  }\n  path.opts.noScope = true;\n  path.remove();\n  path.opts.noScope = false;\n}\n\nfunction assertCjsTransformEnabled(\n  path: NodePath,\n  pass: PluginPass,\n  wrong: string,\n  suggestion: string,\n  extra: string = \"\",\n): void {\n  if (pass.file.get(\"@babel/plugin-transform-modules-*\") !== \"commonjs\") {\n    throw path.buildCodeFrameError(\n      `\\`${wrong}\\` is only supported when compiling modules to CommonJS.\\n` +\n        `Please consider using \\`${suggestion}\\`${extra}, or add ` +\n        `@babel/plugin-transform-modules-commonjs to your Babel config.`,\n    );\n  }\n}\n\nexport interface Options extends SyntaxOptions {\n  /** @default true */\n  allowNamespaces?: boolean;\n  /** @default \"React.createElement\" */\n  jsxPragma?: string;\n  /** @default \"React.Fragment\" */\n  jsxPragmaFrag?: string;\n  onlyRemoveTypeImports?: boolean;\n  optimizeConstEnums?: boolean;\n  allowDeclareFields?: boolean;\n}\n\ntype ExtraNodeProps = {\n  declare?: unknown;\n  accessibility?: unknown;\n  abstract?: unknown;\n  optional?: unknown;\n  override?: unknown;\n};\n\nexport default declare((api, opts: Options) => {\n  // `@babel/core` and `@babel/types` are bundled in some downstream libraries.\n  // Ref: https://github.com/babel/babel/issues/15089\n  const { types: t, template } = api;\n\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const JSX_PRAGMA_REGEX = /\\*?\\s*@jsx((?:Frag)?)\\s+(\\S+)/;\n\n  const {\n    allowNamespaces = true,\n    jsxPragma = \"React.createElement\",\n    jsxPragmaFrag = \"React.Fragment\",\n    onlyRemoveTypeImports = false,\n    optimizeConstEnums = false,\n  } = opts;\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // eslint-disable-next-line no-var\n    var { allowDeclareFields = false } = opts;\n  }\n\n  const classMemberVisitors = {\n    field(\n      path: NodePath<\n        (t.ClassPrivateProperty | t.ClassProperty | t.ClassAccessorProperty) &\n          ExtraNodeProps\n      >,\n    ) {\n      const { node } = path;\n\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!allowDeclareFields && node.declare) {\n          throw path.buildCodeFrameError(\n            `The 'declare' modifier is only allowed when the 'allowDeclareFields' option of ` +\n              `@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.`,\n          );\n        }\n      }\n      if (node.declare) {\n        if (node.value) {\n          throw path.buildCodeFrameError(\n            `Fields with the 'declare' modifier cannot be initialized here, but only in the constructor`,\n          );\n        }\n        if (!node.decorators) {\n          path.remove();\n        }\n      } else if (node.definite) {\n        if (node.value) {\n          throw path.buildCodeFrameError(\n            `Definitely assigned fields cannot be initialized here, but only in the constructor`,\n          );\n        }\n        if (!process.env.BABEL_8_BREAKING) {\n          // keep the definitely assigned fields only when `allowDeclareFields` (equivalent of\n          // Typescript's `useDefineForClassFields`) is true\n          if (\n            !allowDeclareFields &&\n            !node.decorators &&\n            !t.isClassPrivateProperty(node)\n          ) {\n            path.remove();\n          }\n        }\n      } else if (node.abstract) {\n        path.remove();\n      } else if (!process.env.BABEL_8_BREAKING) {\n        if (\n          !allowDeclareFields &&\n          !node.value &&\n          !node.decorators &&\n          !t.isClassPrivateProperty(node)\n        ) {\n          path.remove();\n        }\n      }\n\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.readonly) node.readonly = null;\n      if (node.optional) node.optional = null;\n      if (node.typeAnnotation) node.typeAnnotation = null;\n      if (node.definite) node.definite = null;\n      if (node.declare) node.declare = null;\n      if (node.override) node.override = null;\n    },\n    method({ node }: NodePath<t.ClassMethod | t.ClassPrivateMethod>) {\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.optional) node.optional = null;\n      if (node.override) node.override = null;\n\n      // Rest handled by Function visitor\n    },\n    constructor(path: NodePath<t.ClassMethod>, classPath: NodePath<t.Class>) {\n      if (path.node.accessibility) path.node.accessibility = null;\n      // Collects parameter properties so that we can add an assignment\n      // for each of them in the constructor body\n      //\n      // We use a WeakSet to ensure an assignment for a parameter\n      // property is only added once. This is necessary for cases like\n      // using `transform-classes`, which causes this visitor to run\n      // twice.\n      const assigns: t.ExpressionStatement[] = [];\n      const { scope } = path;\n      for (const paramPath of path.get(\"params\")) {\n        const param = paramPath.node;\n        if (param.type === \"TSParameterProperty\") {\n          const parameter = param.parameter;\n          if (PARSED_PARAMS.has(parameter)) continue;\n          PARSED_PARAMS.add(parameter);\n          let id;\n          if (t.isIdentifier(parameter)) {\n            id = parameter;\n          } else if (\n            t.isAssignmentPattern(parameter) &&\n            t.isIdentifier(parameter.left)\n          ) {\n            id = parameter.left;\n          } else {\n            throw paramPath.buildCodeFrameError(\n              \"Parameter properties can not be destructuring patterns.\",\n            );\n          }\n          assigns.push(\n            template.statement.ast`\n              this.${t.cloneNode(id)} = ${t.cloneNode(id)}\n            ` as t.ExpressionStatement,\n          );\n\n          paramPath.replaceWith(paramPath.get(\"parameter\"));\n          scope.registerBinding(\"param\", paramPath);\n        }\n      }\n      injectInitialization(classPath, path, assigns);\n    },\n  };\n\n  return {\n    name: \"transform-typescript\",\n    inherits: syntaxTypeScript,\n\n    visitor: {\n      //\"Pattern\" alias doesn't include Identifier or RestElement.\n      Pattern: visitPattern,\n      Identifier: visitPattern,\n      RestElement: visitPattern,\n\n      Program: {\n        enter(path, state) {\n          const { file } = state;\n          let fileJsxPragma = null;\n          let fileJsxPragmaFrag = null;\n          const programScope = path.scope;\n\n          if (!GLOBAL_TYPES.has(programScope)) {\n            GLOBAL_TYPES.set(programScope, new Set());\n          }\n\n          if (file.ast.comments) {\n            for (const comment of file.ast.comments) {\n              const jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);\n              if (jsxMatches) {\n                if (jsxMatches[1]) {\n                  // isFragment\n                  fileJsxPragmaFrag = jsxMatches[2];\n                } else {\n                  fileJsxPragma = jsxMatches[2];\n                }\n              }\n            }\n          }\n\n          let pragmaImportName = fileJsxPragma || jsxPragma;\n          if (pragmaImportName) {\n            [pragmaImportName] = pragmaImportName.split(\".\");\n          }\n\n          let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;\n          if (pragmaFragImportName) {\n            [pragmaFragImportName] = pragmaFragImportName.split(\".\");\n          }\n\n          // remove type imports\n          for (let stmt of path.get(\"body\") as Iterable<\n            NodePath<t.Statement | t.Expression>\n          >) {\n            if (stmt.isImportDeclaration()) {\n              if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n                NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n              }\n\n              if (stmt.node.importKind === \"type\") {\n                for (const specifier of stmt.node.specifiers) {\n                  registerGlobalType(programScope, specifier.local.name);\n                }\n                stmt.remove();\n                continue;\n              }\n\n              const importsToRemove: Set<NodePath<t.Node>> = new Set();\n              const specifiersLength = stmt.node.specifiers.length;\n              const isAllSpecifiersElided = () =>\n                specifiersLength > 0 &&\n                specifiersLength === importsToRemove.size;\n\n              for (const specifier of stmt.node.specifiers) {\n                if (\n                  specifier.type === \"ImportSpecifier\" &&\n                  specifier.importKind === \"type\"\n                ) {\n                  registerGlobalType(programScope, specifier.local.name);\n                  const binding = stmt.scope.getBinding(specifier.local.name);\n                  if (binding) {\n                    importsToRemove.add(binding.path);\n                  }\n                }\n              }\n\n              // If onlyRemoveTypeImports is `true`, only remove type-only imports\n              // and exports introduced in TypeScript 3.8.\n              if (onlyRemoveTypeImports) {\n                NEEDS_EXPLICIT_ESM.set(path.node, false);\n              } else {\n                // Note: this will allow both `import { } from \"m\"` and `import \"m\";`.\n                // In TypeScript, the former would be elided.\n                if (stmt.node.specifiers.length === 0) {\n                  NEEDS_EXPLICIT_ESM.set(path.node, false);\n                  continue;\n                }\n\n                for (const specifier of stmt.node.specifiers) {\n                  const binding = stmt.scope.getBinding(specifier.local.name);\n\n                  // The binding may not exist if the import node was explicitly\n                  // injected by another plugin. Currently core does not do a good job\n                  // of keeping scope bindings synchronized with the AST. For now we\n                  // just bail if there is no binding, since chances are good that if\n                  // the import statement was injected then it wasn't a typescript type\n                  // import anyway.\n                  if (binding && !importsToRemove.has(binding.path)) {\n                    if (\n                      isImportTypeOnly({\n                        binding,\n                        programPath: path,\n                        pragmaImportName,\n                        pragmaFragImportName,\n                      })\n                    ) {\n                      importsToRemove.add(binding.path);\n                    } else {\n                      NEEDS_EXPLICIT_ESM.set(path.node, false);\n                    }\n                  }\n                }\n              }\n\n              if (isAllSpecifiersElided() && !onlyRemoveTypeImports) {\n                stmt.remove();\n              } else {\n                for (const importPath of importsToRemove) {\n                  importPath.remove();\n                }\n              }\n\n              continue;\n            }\n\n            if (!onlyRemoveTypeImports && stmt.isTSImportEqualsDeclaration()) {\n              const { id } = stmt.node;\n              const binding = stmt.scope.getBinding(id.name);\n              if (\n                binding &&\n                (process.env.BABEL_8_BREAKING ||\n                  // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n                  !stmt.node.isExport) &&\n                isImportTypeOnly({\n                  binding,\n                  programPath: path,\n                  pragmaImportName,\n                  pragmaFragImportName,\n                })\n              ) {\n                stmt.remove();\n                continue;\n              }\n            }\n\n            if (stmt.isExportDeclaration()) {\n              stmt = stmt.get(\"declaration\");\n            }\n\n            if (stmt.isVariableDeclaration({ declare: true })) {\n              for (const name of Object.keys(stmt.getBindingIdentifiers())) {\n                registerGlobalType(programScope, name);\n              }\n            } else if (\n              stmt.isTSTypeAliasDeclaration() ||\n              (stmt.isTSDeclareFunction() && stmt.get(\"id\").isIdentifier()) ||\n              stmt.isTSInterfaceDeclaration() ||\n              stmt.isClassDeclaration({ declare: true }) ||\n              stmt.isTSEnumDeclaration({ declare: true }) ||\n              (stmt.isTSModuleDeclaration({ declare: true }) &&\n                stmt.get(\"id\").isIdentifier())\n            ) {\n              registerGlobalType(\n                programScope,\n                (stmt.node.id as t.Identifier).name,\n              );\n            }\n          }\n        },\n        exit(path) {\n          if (\n            path.node.sourceType === \"module\" &&\n            NEEDS_EXPLICIT_ESM.get(path.node)\n          ) {\n            // If there are no remaining value exports, this file can no longer\n            // be inferred to be ESM. Leave behind an empty export declaration\n            // so it can be.\n            path.pushContainer(\"body\", t.exportNamedDeclaration());\n          }\n        },\n      },\n\n      ExportNamedDeclaration(path, state) {\n        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n        }\n\n        if (path.node.exportKind === \"type\") {\n          path.remove();\n          return;\n        }\n\n        if (\n          process.env.BABEL_8_BREAKING &&\n          t.isTSImportEqualsDeclaration(path.node.declaration)\n        ) {\n          return;\n        }\n\n        // remove export declaration that is filled with type-only specifiers\n        //   export { type A1, type A2 } from \"a\";\n        if (\n          path.node.source &&\n          path.node.specifiers.length > 0 &&\n          path.node.specifiers.every(\n            specifier =>\n              specifier.type === \"ExportSpecifier\" &&\n              specifier.exportKind === \"type\",\n          )\n        ) {\n          path.remove();\n          return;\n        }\n\n        // remove export declaration if it's exporting only types\n        // This logic is needed when exportKind is \"value\", because\n        // currently the \"type\" keyword is optional.\n        // TODO:\n        // Also, currently @babel/parser sets exportKind to \"value\" for\n        //   export interface A {}\n        //   etc.\n        if (\n          !path.node.source &&\n          path.node.specifiers.length > 0 &&\n          path.node.specifiers.every(\n            specifier =>\n              t.isExportSpecifier(specifier) &&\n              isGlobalType(path, specifier.local.name),\n          )\n        ) {\n          path.remove();\n          return;\n        }\n\n        // Convert `export namespace X {}` into `export let X; namespace X {}`,\n        // so that when visiting TSModuleDeclaration we do not have to possibly\n        // replace its parent path.\n        if (t.isTSModuleDeclaration(path.node.declaration)) {\n          const namespace = path.node.declaration;\n          if (!t.isStringLiteral(namespace.id)) {\n            const id = getFirstIdentifier(namespace.id);\n            if (path.scope.hasOwnBinding(id.name)) {\n              path.replaceWith(namespace);\n            } else {\n              const [newExport] = path.replaceWithMultiple([\n                t.exportNamedDeclaration(\n                  t.variableDeclaration(\"let\", [\n                    t.variableDeclarator(t.cloneNode(id)),\n                  ]),\n                ),\n                namespace,\n              ]);\n              path.scope.registerDeclaration(newExport);\n            }\n          }\n        }\n\n        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);\n      },\n\n      ExportAllDeclaration(path) {\n        if (path.node.exportKind === \"type\") path.remove();\n      },\n\n      ExportSpecifier(path) {\n        // remove type exports\n        type Parent = t.ExportDeclaration & { source?: t.StringLiteral };\n        const parent = path.parent as Parent;\n        if (\n          (!parent.source && isGlobalType(path, path.node.local.name)) ||\n          path.node.exportKind === \"type\"\n        ) {\n          path.remove();\n        }\n      },\n\n      ExportDefaultDeclaration(path, state) {\n        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n        }\n\n        // remove whole declaration if it's exporting a TS type\n        if (\n          t.isIdentifier(path.node.declaration) &&\n          isGlobalType(path, path.node.declaration.name)\n        ) {\n          path.remove();\n\n          return;\n        }\n\n        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);\n      },\n\n      TSDeclareFunction(path) {\n        safeRemove(path);\n      },\n\n      TSDeclareMethod(path) {\n        safeRemove(path);\n      },\n\n      VariableDeclaration(path) {\n        if (path.node.declare) {\n          safeRemove(path);\n        }\n      },\n\n      VariableDeclarator({ node }) {\n        if (node.definite) node.definite = null;\n      },\n\n      TSIndexSignature(path) {\n        path.remove();\n      },\n\n      ClassDeclaration(path) {\n        const { node } = path;\n        if (node.declare) {\n          safeRemove(path);\n        }\n      },\n\n      Class(path) {\n        const { node }: { node: typeof path.node & ExtraNodeProps } = path;\n\n        if (node.typeParameters) node.typeParameters = null;\n        if (process.env.BABEL_8_BREAKING) {\n          // @ts-ignore(Babel 7 vs Babel 8) Renamed\n          if (node.superTypeArguments) node.superTypeArguments = null;\n        } else {\n          // @ts-ignore(Babel 7 vs Babel 8) Renamed\n          if (node.superTypeParameters) node.superTypeParameters = null;\n        }\n        if (node.implements) node.implements = null;\n        if (node.abstract) node.abstract = null;\n\n        // Similar to the logic in `transform-flow-strip-types`, we need to\n        // handle `TSParameterProperty` and `ClassProperty` here because the\n        // class transform would transform the class, causing more specific\n        // visitors to not run.\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassMethod() || child.isClassPrivateMethod()) {\n            if (child.node.kind === \"constructor\") {\n              classMemberVisitors.constructor(\n                // @ts-expect-error A constructor must not be a private method\n                child,\n                path,\n              );\n            } else {\n              classMemberVisitors.method(child);\n            }\n          } else if (\n            child.isClassProperty() ||\n            child.isClassPrivateProperty() ||\n            child.isClassAccessorProperty()\n          ) {\n            classMemberVisitors.field(child);\n          }\n        });\n      },\n\n      Function(path) {\n        const { node } = path;\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.returnType) node.returnType = null;\n\n        const params = node.params;\n        if (params.length > 0 && t.isIdentifier(params[0], { name: \"this\" })) {\n          params.shift();\n        }\n      },\n\n      TSModuleDeclaration(path) {\n        transpileNamespace(path, allowNamespaces);\n      },\n\n      TSInterfaceDeclaration(path) {\n        path.remove();\n      },\n\n      TSTypeAliasDeclaration(path) {\n        path.remove();\n      },\n\n      TSEnumDeclaration(path) {\n        if (optimizeConstEnums && path.node.const) {\n          transpileConstEnum(path as NodePathConstEnum, t);\n        } else {\n          transpileEnum(path, t);\n        }\n      },\n\n      TSImportEqualsDeclaration(\n        path: NodePath<t.TSImportEqualsDeclaration>,\n        pass,\n      ) {\n        const { id, moduleReference } = path.node;\n\n        let init: t.Expression;\n        let varKind: \"var\" | \"const\";\n        if (t.isTSExternalModuleReference(moduleReference)) {\n          // import alias = require('foo');\n          assertCjsTransformEnabled(\n            path,\n            pass,\n            `import ${id.name} = require(...);`,\n            `import ${id.name} from '...';`,\n            \" alongside Typescript's --allowSyntheticDefaultImports option\",\n          );\n          init = t.callExpression(t.identifier(\"require\"), [\n            moduleReference.expression,\n          ]);\n          varKind = \"const\";\n        } else {\n          // import alias = Namespace;\n          init = entityNameToExpr(moduleReference);\n          varKind = \"var\";\n        }\n        const newNode = t.variableDeclaration(varKind, [\n          t.variableDeclarator(id, init),\n        ]);\n\n        if (process.env.BABEL_8_BREAKING) {\n          path.replaceWith(newNode);\n        } else {\n          path.replaceWith(\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            path.node.isExport ? t.exportNamedDeclaration(newNode) : newNode,\n          );\n        }\n        path.scope.registerDeclaration(path);\n      },\n\n      TSExportAssignment(path, pass) {\n        assertCjsTransformEnabled(\n          path,\n          pass,\n          `export = <value>;`,\n          `export default <value>;`,\n        );\n        path.replaceWith(\n          template.statement.ast`module.exports = ${path.node.expression}`,\n        );\n      },\n\n      TSTypeAssertion(path) {\n        path.replaceWith(path.node.expression);\n      },\n\n      [`TSAsExpression${\n        // Added in Babel 7.20.0\n        t.tsSatisfiesExpression ? \"|TSSatisfiesExpression\" : \"\"\n      }`](path: NodePath<t.TSAsExpression | t.TSSatisfiesExpression>) {\n        let { node }: { node: t.Expression } = path;\n        do {\n          node = node.expression;\n        } while (t.isTSAsExpression(node) || t.isTSSatisfiesExpression?.(node));\n        path.replaceWith(node);\n      },\n\n      [process.env.BABEL_8_BREAKING\n        ? \"TSNonNullExpression|TSInstantiationExpression\"\n        : /* This has been introduc